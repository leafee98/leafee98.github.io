<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>shell符号总结【上】 | Leafee’s Blog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="shell符号总结【上】" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="关于符号" />
<meta property="og:description" content="关于符号" />
<link rel="canonical" href="http://localhost:4000/linux/2019/07/20/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
<meta property="og:url" content="http://localhost:4000/linux/2019/07/20/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
<meta property="og:site_name" content="Leafee’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-20T15:46:09+08:00" />
<script type="application/ld+json">
{"description":"关于符号","@type":"BlogPosting","headline":"shell符号总结【上】","dateModified":"2019-07-20T15:46:09+08:00","datePublished":"2019-07-20T15:46:09+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/linux/2019/07/20/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},"url":"http://localhost:4000/linux/2019/07/20/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Leafee's Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Leafee&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/tags.html">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">shell符号总结【上】</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-20T15:46:09+08:00" itemprop="datePublished">Jul 20, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="关于符号">关于符号</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">$</code> 美元符号, 一般用于取变量的值, 不过总觉得和命令代换有很多相似之处, 具体可见样例, 另外美元符号也会和其他符号产生有意思的组合.</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ var</span><span class="o">=</span><span class="s2">"echo hello"</span>
  <span class="nv">$ $var</span>
  hello
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">[]</code> 相当于test命令, 用于测试条件是否成立, 若成立则退出值为0(真), 由于if, for, case等结构语句通过上一条命令的退出值来决定运行流程, 因此方括号多用于这些结构语句中.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">$()</code> , <code class="highlighter-rouge">` `</code> 两种用法相同, 均是命令代换, 即取所包含的命令的输出作为文本值参与运行, 文本值甚至可以是命令, 如直接运行<code class="highlighter-rouge">`echo pwd`</code>则相当于直接运行<code class="highlighter-rouge">pwd</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">$[]</code> 对于此命令需要提前了解双反引号(上一条), 以及<code class="highlighter-rouge">expr</code>命令, <code class="highlighter-rouge">expr</code>官方描述为<em>Print the value of EXPRESSION to standard output</em>, 所以可以把<code class="highlighter-rouge">expr</code>命令做命令代换, 于是<code class="highlighter-rouge">$[]</code>与<code class="highlighter-rouge"> `expr expression`</code>效果相同, 样例如下.</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ var1</span><span class="o">=</span><span class="sb">`</span><span class="nb">expr </span>1 + 1<span class="sb">`</span>
  <span class="nv">$ var2</span><span class="o">=</span><span class="nv">$[</span>1 + 1]
  <span class="nv">$ </span><span class="nb">echo </span><span class="nv">var1</span><span class="o">=</span><span class="nv">$var1</span> <span class="nv">var2</span><span class="o">=</span><span class="nv">$var2</span>
  <span class="nv">var1</span><span class="o">=</span>2 <span class="nv">var2</span><span class="o">=</span>2
</code></pre></div>    </div>

    <p>不过有一点奇怪的是, 以下命令的运行结果并不能如我所愿输出<code class="highlighter-rouge">hello</code>, 不过至少反引号和美元符号加方括号的行为是一样的, 仍然支持我的猜想.</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">alias </span><span class="nv">2</span><span class="o">=</span><span class="s2">"echo hello"</span>
  <span class="nv">$ </span><span class="nb">alias
  alias </span><span class="nv">2</span><span class="o">=</span><span class="s1">'echo hello'</span>
  <span class="nv">$ </span><span class="sb">`</span><span class="nb">expr </span>1 + 1<span class="sb">`</span>
  bash: 2: <span class="nb">command </span>not found
  <span class="nv">$ $[</span>1 + 1]
  bash: 2: <span class="nb">command </span>not found
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">;</code> 可用于分隔命令, 书本上翻译为命令列表, 一般来说, 命令与命令之间通过换行符来进行分隔, 但是有时为了追求代码的紧凑会希望将几条命令放在同一行, 于是这便是分号的用途.</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="o">[</span> expression <span class="o">]</span> <span class="p">;</span> <span class="k">then
      </span><span class="nb">command
  </span><span class="k">fi</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">()</code> 用于表示数组, 数组样例见下一个符号的样例, 也用于进程列表, 进程列表中的命令会被开一个子shell运行, 进程列表样例如下.</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$BASH_SUBSHELL</span>           <span class="c"># 当前子shell水平为0</span>
  0
  <span class="nv">$ </span><span class="o">(</span><span class="nb">echo</span> <span class="nv">$BASH_SUBSHELL</span><span class="o">)</span>	        <span class="c"># 当前子shell水平为0</span>
  1
</code></pre></div>    </div>

    <p>那么之前的命令代换中的括号是否也会被开一个子shell呢,</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$BASH_SUBSHELL</span>           <span class="c"># 当前子shell水平为0</span>
  0
  <span class="nv">$ </span><span class="nb">echo</span> <span class="si">$(</span><span class="nb">echo</span> <span class="nv">$BASH_SUBSHELL</span><span class="si">)</span>   <span class="c"># 命令代换中子shell水平为1</span>
  1
</code></pre></div>    </div>

    <p>猜想得证.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">${}</code> 此符号用于取数组的值, 需要注意的一点是, 当数组中某一个位置的值被<code class="highlighter-rouge">unset</code>之后, 该位置后面的值并不会自动向前移动一个序号, 可见样例.</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ arr</span><span class="o">=(</span> 1 2 3 <span class="o">)</span>
  <span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[2]</span><span class="k">}</span>
  3
  <span class="nv">$ </span><span class="nb">unset </span>arr[1]
  <span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[2]</span><span class="k">}</span>
  3
  <span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">arr</span><span class="p">[1]</span><span class="k">}</span>
                                  <span class="c">#空行, 无输出</span>
  <span class="nv">$ </span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">[[ ]]</code> <code class="highlighter-rouge">(( ))</code> 双方括号是拓展字符运算, 双圆括号是拓展数学运算, 其中拓展数学运算可支持移位操作,自增操作等高级操作, 拓展字符运算可支持通配符匹配.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">;;</code> 双分号用于case的匹配中, 与单分号不同的是, 单分号只能结束当前命令, 后续仍被认为是这一块的可执行语句, 不能接下一个匹配条件, 只有以双分号结尾, 才能接下一个匹配</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>caseExample.sh
<span class="nv">var</span><span class="o">=</span>2
<span class="k">case</span> <span class="nv">$var</span> <span class="k">in
</span>1 <span class="p">|</span> 2 <span class="p">)</span>
    <span class="nb">echo </span>1 <span class="p">;</span>
    <span class="nb">echo </span>2 <span class="p">;;</span>
3 <span class="p">|</span> 4 <span class="p">)</span>
    <span class="nb">echo </span>3 <span class="p">;</span>
    <span class="nb">echo </span>4 <span class="p">;;</span>
<span class="k">esac</span>
<span class="nv">$ </span>./caseExample.sh
1
2
<span class="nv">$ </span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="关于结构化语句">关于结构化语句</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">if</code> 判断语句</p>

    <ul>
      <li>
        <p>判断的方法只是简单地根据上一命令的返回值来判断执行结构, 关于这一点, 其实最常用的方括号只是<code class="highlighter-rouge">test</code>命令, 这一点在上面符号的部分有提及. 通常用法是</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if </span>command1 <span class="p">;</span> <span class="k">then
      </span>command2
  <span class="k">fi</span>
</code></pre></div>        </div>

        <p>以上用法中, <code class="highlighter-rouge">command1</code>是任意一个可执行的shell命令, <code class="highlighter-rouge">command2</code>是条件为真则执行的语句体, 最后<code class="highlighter-rouge">if</code>语句使用<code class="highlighter-rouge">fi</code>进行结尾. 需要注意的是, <strong><code class="highlighter-rouge">command1</code>的返回值若是<code class="highlighter-rouge">0</code>则<code class="highlighter-rouge">if</code>判断为真, 非<code class="highlighter-rouge">0</code>则判断为假</strong>, 这一点与许多类C语言恰恰相反. 另外, <code class="highlighter-rouge">command1</code>是按照通常的命令执行方式执行的, 所以如果<code class="highlighter-rouge">command1</code>命令有输出, 则会直接输出在控制台中.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">if</code>语句也可以在条件为假的时候执行语句, 方法是在结尾<code class="highlighter-rouge">fi</code>之前加入一个<code class="highlighter-rouge">else</code>; 当然<code class="highlighter-rouge">if</code>也可以判断多个条件进行筛选, 方法是使用<code class="highlighter-rouge">elfi</code>, 样例如下</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if </span>command1 <span class="p">;</span> <span class="k">then
      </span>command2
  <span class="k">elif </span>command3 <span class="p">;</span> <span class="k">then
      </span>command4
  <span class="k">else
      </span>command5
  <span class="k">fi</span>
</code></pre></div>        </div>

        <p>为了代码紧凑, 有时候会在判断命令之后使用分号进行分隔, 并把<code class="highlighter-rouge">then</code>放在同一行的之后</p>
      </li>
      <li>
        <p>​    <code class="highlighter-rouge">if</code>语句中也可以使用逻辑运算符, 和其他许多类C语言类似, 使用<code class="highlighter-rouge">&amp;&amp;</code>, <code class="highlighter-rouge">||</code>, <code class="highlighter-rouge">!</code>, 分别作为与,或,非. 这些逻辑运算符可以用在<code class="highlighter-rouge">test</code>命令和普通命令之中. 需要注意的是, 在<code class="highlighter-rouge">test</code>手册中并没有<code class="highlighter-rouge">&amp;&amp;</code>,<code class="highlighter-rouge">||</code>的表述, 不过这些仍然被支持, 因为在shell中, <code class="highlighter-rouge">&amp;&amp;</code>的行为是若该符号之前的命令运行的返回值为<strong>真</strong>, 则执行下一条命令, <code class="highlighter-rouge">||</code>的行为是若该符号之前的命令运行返回值为<strong>假</strong>, 则执行下一条命令, 这个被称为”短路”, 在C语言中同样适用. 
​    所以如此来看的话, 使用<code class="highlighter-rouge">command1 &amp;&amp; command2</code>的作为分析, 如果<code class="highlighter-rouge">command1</code>返回值为真, 则执行<code class="highlighter-rouge">command2</code>, 此时整个逻辑表达式的值就由<code class="highlighter-rouge">command2</code>的返回值决定, 若<code class="highlighter-rouge">command2</code>的返回值也为真, 则最后<code class="highlighter-rouge">$?</code>的值就是真, 反之则假. 若<code class="highlighter-rouge">command1</code>返回值为假, 则短路, 最终整个逻辑运算的结果就是<code class="highlighter-rouge">command1</code>的返回值–假. 原因是逻辑运算符的作用仅仅是决定是否进行短路, 而且条件判断依据仅仅是之前运行的最后一条命令的返回值, 于是整个逻辑运算十分顺利. 或运算同理. 
​    至于非运算, 叹号<code class="highlighter-rouge">!</code>其实也是一条命令, 这一点可以在终端不输入任何字符的情况下敲入双tab, 使其打印所有的可执行命令, 其中第一条就是<code class="highlighter-rouge">!</code>. 样例如下</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">!</span> <span class="nb">echo</span> <span class="s1">'hello'</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">'true'</span> <span class="p">;</span> <span class="nb">echo</span> <span class="nv">$?</span>
hello
1
<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'hello'</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">'true'</span> <span class="p">;</span> <span class="nb">echo</span> <span class="nv">$?</span>
hello
<span class="nb">true
</span>0
<span class="nv">$ </span><span class="o">!</span> <span class="nb">echo</span> <span class="s1">'hello'</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s1">'true'</span> <span class="p">;</span> <span class="nb">echo</span> <span class="nv">$?</span>
<span class="s1">'hello'</span>
<span class="s1">'true'</span>
0
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="特殊变量">特殊变量</h2>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$$</td>
      <td>当前shell进程的PID</td>
    </tr>
    <tr>
      <td>$?</td>
      <td>上一命令运行的返回值</td>
    </tr>
    <tr>
      <td>$#</td>
      <td>命令行脚本传递参数的个数</td>
    </tr>
    <tr>
      <td>$@</td>
      <td>作为数组(雾)获取全部命令行参数</td>
    </tr>
    <tr>
      <td>$*</td>
      <td>作为一整条字符串获取全部命令行参数</td>
    </tr>
    <tr>
      <td>$0</td>
      <td>当前shell脚本的运行名(脚本的绝对路径或者相对路径)</td>
    </tr>
    <tr>
      <td>$n</td>
      <td>shell脚本的第n个参数</td>
    </tr>
  </tbody>
</table>

  </div><a class="u-url" href="/linux/2019/07/20/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Leafee&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Leafee&#39;s Blog</li><li><a class="u-email" href="mailto:leafee98@hotmail.com">leafee98@hotmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/leafee98"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">leafee98</span></a></li><li><a href="https://www.twitter.com/leafee98"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">leafee98</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Leafee&#39;s blog based on jekyll</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

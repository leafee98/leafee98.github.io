---
title: C++迭代器易bug点
date: 2019-07-30 15:48:48 +0800
layout: post
categories: c++
tags: c++
---

**在对容器进行迭代时，尽可能避免对容器内容的修改，如确实需要修改，则一定要注意容器被修改后当前迭代器的位置是否仍然可用。**

## 错误代码例

以下代码为[一次训练赛D题](http://codeforces.com/gym/247981/problem/D)的尝试作答，原题面为

> 输入每个人的电话号码，将其整理后输出，人名顺序可以为字母序，每个人的电话号码也可以为字母序。
>
> 规定一个人如果有多个相同号码，则视之为一个号码；如果有多个不同长度的号码，且较长的号码意较短的号码为后缀，则视较短的号码为冗余号码；有多个人共享同一个号码的情况
>
> > 第一行输入一个数字代表接下来要输入的行数，
> > 每行起始一个字符串代表一个人的姓名，接下来一个数字n表示后边的数字的个数，接下来n个数字代表属于这个人的电话号码们
> >
> > ```
> > INPUT:
> > 4
> > ivan 3 123 123 456
> > ivan 2 456 456
> > ivan 8 789 3 23 6 56 9 89 2
> > dasha 2 23 789
> > 
> > OUTPUT:
> > 2
> > dasha 2 23 789 
> > ivan 4 789 123 2 456 
> > ```
> >
> > ```
> > INPUT:
> > 3
> > karl 2 612 12
> > petr 1 12
> > katya 1 612
> > 
> > OUTPUT:
> > 3
> > katya 1 612 
> > petr 1 12 
> > karl 1 612 
> > ```

 解题思路为使用一个`map<string, set<string>>`容器，`map`以人名为键，以所有的电话号码为值，而在`set`中，电话号码倒序存储。

在遍历一个人的所有电话号码时，只需要比较相邻的两个号码，前一个是否是后一个的前缀即可，若是，则移除前一个，若否，则遍历下一个，直到倒数第二个。

```c++
#include <iostream>
#include <map>
#include <string>
#include <set>
using namespace std;

int main() {
    map<string, set<string>> records;
    int n;
    cin >> n;
    while (n-- > 0) {
        string name, number;
        int amount;
        cin >> name >> amount;
        while (amount-- > 0) {
            cin >> number;
            string temp(number.rbegin(), number.rend());
            records[name].emplace(temp);
        }
    }

    for (map<string, set<string>>::iterator it = records.begin(); it != records.end(); ++it) {
        set<string> & numbers = it->second;
        for (set<string>::iterator iu = numbers.begin(); iu != numbers.end(); ++iu) {
            set<string>::iterator iv = iu;		// the iterator right adjacent to iu
            if (iv != numbers.end()) {
                ++iv;
                const string & pointToStr= *iv;
                string copyStr = string(pointToStr);
                string tmpStr = copyStr.substr(0, iu->size());
                if (iv->size() >= iu->size() && (*iu == tmpStr))
                    numbers.erase(*iu);
            }
        }
        set<string> reverseSet;
        reverseSet.swap(numbers);
        for (set<string>::iterator iw = reverseSet.begin(); iw != reverseSet.end(); ++iw)
            numbers.emplace(string(iw->rbegin(), iw->rend()));
    }

    for (auto it = records.begin(); it != records.end(); ++it) {
        cout << it->first << ' ' << it->second.size();
        for (set<string>::iterator iu = it->second.begin(); iu != it->second.end(); ++iu)
            cout << *iu << ' ';
        cout << endl;
    }

    return 0;
}
```

以上代码在自己调配的`VS Code` + `g++`（on Windows）环境下会在第二个循环中`string tmpStr = copyStr.substr(0, iu->size());`的位置崩溃，且没有任何提示。

在Visual Studio中，会以弹窗的形式报`cannot dereference end map/set/ iterator`错误，报错位置是第二个循环的`for (set<string>::iterator iu = numbers.begin(); iu != numbers.end(); ++iu) {`，报错条件是判断语句中的`numbers.erase(*iu);` 执行后。

综上，错误原因是**当`*iu`的内容被移除后，迭代器`iu`所指向的位置就已经失效了，再次进行自增操作则会由于操作已经销毁的内存而程序崩溃。**

修改后的代码如下，但是**并没有AC**

```C++
#include <iostream>
#include <map>
#include <string>
#include <set>
using namespace std;

int main() {
	map<string, set<string>> records;
	int n;
	cin >> n;
	while (n-- > 0) {
		string name, number;
		int amount;
		cin >> name >> amount;
		while (amount-- > 0) {
			cin >> number;
			string temp(number.rbegin(), number.rend());
			records[name].emplace(temp);
		}
	}

	for (map<string, set<string>>::iterator it = records.begin(); it != records.end(); ++it) {
		set<string>& numbers = it->second;
		for (set<string>::iterator iu = numbers.begin(); iu != numbers.end(); ) {
			set<string>::iterator iv = iu;		// the iterator right adjacent to iu
			++iv;
			if (iv != numbers.end()) {
				const string& pointToStr = *iv;
				string copyStr = string(pointToStr);
				string tmpStr = copyStr.substr(0, iu->size());
				if (iv->size() >= iu->size() && *iu == tmpStr)
					numbers.erase(tmpStr);
				iu = iv;			// ++iu
			} else {
				break;
			}
		}
		set<string> reverseSet;
		reverseSet.swap(numbers);
		for (set<string>::iterator iw = reverseSet.begin(); iw != reverseSet.end(); ++iw)
			numbers.emplace(string(iw->rbegin(), iw->rend()));
	}

	for (auto it = records.begin(); it != records.end(); ++it) {
		cout << it->first << ' ' << it->second.size() << ' ';
		for (set<string>::iterator iu = it->second.begin(); iu != it->second.end(); ++iu)
			cout << *iu << ' ';
		cout << endl;
	}

	return 0;
}
```
